> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qq_43371422/article/details/123264745?spm=1001.2014.3001.5502)

#### 文章目录

*   *   [数组、数组操作与实际案例](#_1)
    *   *   [1. 定义数组的格式](#1__7)
        *   *   [**1.1 格式：**](#11__9)
            *   [**1.2 数组格式介绍:**](#12__15)
        *   [2. 数组的操作与下标问题](#2_49)
        *   [3. 下标越界问题](#3__105)

### 数组、数组操作与实际案例

数组是用来解决开发中【相同数据类型】的，【大量】的数据操作的。

#### 1. [定义数组](https://so.csdn.net/so/search?q=%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020)的格式

##### **1.1 格式：**

```
数据类型[] 数组名 = new 数据类型[容量];

```

##### **1.2 数组格式介绍:**

*   赋值号左侧
    
    1.  数据类型：
    
    明确数据存储的数据类型，并且可且仅可以储存对应的数据类型。此为【数据类型一致化要求】
    
    2.  []:
    
    表示当前定义的是一个数组类型 【数组自成一个数据类型】
    
    3.  数组名：
    
    数组名是一个【[引用数据类型](https://so.csdn.net/so/search?q=%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020)】的【变量】，具有指向性和跳转性
    
*   赋值号右侧
    
    1.  new:
    
    在内存的【堆区】申请可以储存当前数组的空间，指定数据类型，指定容量的数据空间。堆区 ==> 仓库，仓库数据存储有边界
    
    new 关键字会擦除申请空间内的所有数据内容，俗称:(打扫卫生)
    
    2.  数据类型:
    
    数据类型要做到前后呼应，明确当前数组可以储存的数据类型是什么，并严格遵守【数据类型一致化】
    
    3.  [容量]:
    
    明确当前数组可以存储多少个指定数据类型，【一旦确认无法修改】
    

#### 2. 数组的操作与下标问题

1.  一个数组的有效下标就是**从 0 开始 到 数组容量 - 1**
2.  数组容量可以用 arr.length 查询，arr 为数组名
3.  正数有可能是有效下标，但是负数一定是【非法下标】

```
// 数组基本操作和下标问题
class Demo1 {
	public static void main(String[] args) {
		/*
		数据类型[] 数组名 = new 数据类型[容量];
		定义一个 int 类型数组 
		数组名 arr 数组容量 10
		*/
		int[] arr = new int[10];
		
		/*
		输出数组的数据信息为数组类型，以及当前数组所在内存地址位置，【仓库位置】
		例：
		[I@15db9742
			[ ==> 数组
			I ==> int
			@ ==> 在哪里 
			15db9742 ==> 十六进制数据展示地址！！！
		*/
		System.out.println(arr);
		
		/*
		一个数组的有效下标范围:
			从 0 开始 到 数组容量 - 1
			数组容量 arr.length
		*/
		System.out.println("数组容量:" + arr.length);
		
		/*
		当前数组有效下标为 0 ~ 9
		【注意】正数有可能是有效下标，但是负数一定是【非法下标】
		
		操作数组中执定下标元素
			数组名[有效下标] 可以进行赋值和取值操作
		*/
		// 给予下标为 5 的元素进行赋值操作
		arr[5] = 20;
		// 给予下标为 0 的元素进行赋值操作
		arr[0] = 100;
		
		// 取值下标为 5 和 0 的元素数据存储内容
		System.out.println("数组下标为 5 的元素数据存储内容:" + arr[5]);
		System.out.println("数组下标为 0 的元素数据存储内容:" + arr[0]);
	}
}

```

#### 3. 下标越界问题

1.  **-1** 是非法数组下标，但是下标数据类型为 int 类型，**-1** 是 int 类型，类型一致所以查询下标为 **-1 ** 的数组元素时，代码编译不报错，但是代码运行报错

```
// 数组下标越界问题 
class Demo2 {
	public static void main(String[] args) {
		// 定义一个数组 int 类型 数组容量为10
		int[] arr = new int[10];
		
		/*
		数组 arr 有效下标 范围为 0 ~ 9
		
		编译不报错:	
			数组名[下标] 下标所需数据类型为 int 类型
			-1 就是对应 int 类型，类型一致，语法通过，编译不报错。
		运行报错:
			Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: -1
				at Demo2.main(Demo2.java:18)
			ArrayIndexOutOfBoundsException: -1 数组下标越界异常 提示目前操作数组下标为 -1
		*/
		// arr[-1] = 10;
		
		/*
		Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10
			at Demo2.main(Demo2.java:25);
			ArrayIndexOutOfBoundsException: 10 数组下标越界异常 提示目前操作数组下标为 10
		*/
		arr[10] = 20;
	}
}

```

[**数组操作实际案例分析**](https://blog.csdn.net/qq_43371422/article/details/123264100)