> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qq_43371422/article/details/125269987?spm=1001.2014.3001.5502)

#### 文章目录

*   *   [一、MyBatis](#MyBatis_1)
    *   *   [Mybatis](#Mybatis_3)
        *   *   [1. 什么是 MyBatis](#1___MyBatis_5)
            *   *   [1.1 MyBatis 简介](#11_MyBatis__7)
                *   [1.2 Mybatis 的特点](#12_Mybatis__17)
            *   [2. Mybatis 延迟加载策略](#2_Mybatis__33)
            *   *   [2.1 什么延迟加载（懒加载）](#21__37)
                *   [2.2 懒加载步骤](#22__47)
            *   [3. Mybatis 缓存](#3_Mybatis__70)
            *   *   [3.1 什么是缓存](#31__74)
                *   [3.2 缓存的配置](#32__88)
                *   [3.3 注意](#33__120)
            *   [4. Mybatis 基于注解开发](#4_Mybatis__132)
            *   *   [4.1 Mybatis 常用注解](#41_Mybatis__136)

### 一、MyBatis

#### Mybatis

##### 1. 什么是 MyBatis

###### 1.1 MyBatis 简介

​ **Mybatis 原名 Ibatis 是一个基于 java 的持久层框架**

​ 支持定制化 Sql、存储过程 和 高级映射 ，相对于 JDBC 完成 ORM （对象关系映射、提供持久化类和表的映射关系）更加方便、简洁。

###### 1.2 Mybatis 的特点

*   ** 简单 易学：** 没有任何三方依赖。
    
*   ** 灵活 ：** 不会对应用程序或者数据库有任何强加的影响。
    
*   ** 解除了 SQL　与程序代码的耦合：** 通过强化　Dao　层，将业务逻辑　和　数据访问逻辑分离，系统更加清晰、更加容易维护、更加易于单元测试。
    
*   ** 提供映射标签：** 支持对象与数据库的 ORM 关系映射 。
    
*   ** 提供 XML：** 支持编写 SQL 。
    

##### 2. Mybatis 延迟加载策略

###### 2.1 什么延迟加载（[懒加载](https://so.csdn.net/so/search?q=%E6%87%92%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020)）

**延迟加载** 就是用到相关数据时 才会进行查询和加载，不用到时就不加载数据。延迟加载又称之为 **懒加载**。

*   **延迟加载的优点：** 少量数据查询时 大大提高了数据库的性能， 因为单表查询 往往比联表查询 多张表 要来的快。
    
*   **延迟加载的缺点：** 大量数据查询时 因为查询工作在需要的时候才会开始查询，反复的查询会消耗大量时间，造成等待时间较长，用户体验不好。
    

###### 2.2 懒加载步骤

1.  开启全局懒加载
    
2.  先行表单查询
    
3.  用到缺少属性才会开启相关查询
    

**开启全局懒加载需要在 MyBatis-config.xml 中设置**

```
 <settings>
     
        <!-- 开启全局懒加载-->
        <setting />
        <setting />
 </settings>

```

##### 3. Mybatis 缓存

###### 3.1 什么是缓存

**缓存：** 一般的 ORM 框架中都会提供的功能，分为 **一级缓存、二级缓存**。

*   **一级缓存：** 基于 SqlSession 级别，又是默认缓存，不用特殊配置默认开启缓存
    
*   **二级缓存：** 基于 Mapper / namespace 级别，可以让多个 SqlSession 共享的缓存空间，需要在 **MyBatis-config.xml** 中配置开启二级缓存，在 XXXMapper.xml 文件中配置 Cache，**二级缓存的数据，都是由一级缓存提交完成的 ，提交方法：（ SqlSession commit().close() )** 。
    
*   **缓存的作用：** 提高查询效率 减少数据库压力。
    

###### 3.2 缓存的配置

**开启二级缓存在 MyBatis-config.xml 中的配置**

```
   <settings>

        <!--开启二级缓存-->
        <setting />
    </settings>

```

**在 mapper.xml 中的配置**

```
    <!--
        开启二级缓存
            eviction = "LRU" 配置缓存的容量 和 使用完毕时的回收策略
                LRU 清除最近最少使用的缓存
                    当缓存满 size = "1000" 条， 则将最近一段时间 最少使用的 那一条缓存数据删除
                FIFO 先进先出
                    当缓存满 size = "1000" 条， 则将按照存储的时间顺序， 先缓存的数据先删除

            flushInterval = "60000" 单位 毫秒， 缓存 60s 清空一次
            readOnly = "true" 查询出来对象只读 数据安全
            blocking = "true" 当查询数据时，如果没有数据，则阻塞 等待数据返回
      -->
    <cache eviction="LRU" size="1000" flushInterval="600000" readOnly="true" blocking="true"></cache>

```

###### 3.3 注意

*   **提交事务：** **SqlSession** 只有在关闭或者提交事务的时候才会提交二级缓存 ，二级缓存不提交的情况下不生效。
    
*   **清理缓存：** **SqlSession** （**一级缓存**）只要数据库查询发生 **增删改** 就会吧所有缓存清除 ，**二级缓存** 只有在当前命名空间发生改变时，缓存才会清除。
    
*   **序列化：** 使用二级缓存的实体类 必须序列化 方便存储
    
*   **一二级缓存的读取顺序：** 缓存的读取过程会先去 **二级缓存** 中读取，没有想要的数据再去 **一级缓存** 中去读取，都没有的情况下才会去数据库查询。即使数据在一个 SqlSession / namespace 中，也会保持这个顺序。
    

##### 4. Mybatis 基于注解开发

###### 4.1 Mybatis 常用注解

​ **@Insert:** 实现新增  
​ **@Update:** 实现更新  
​ **@Delete:** 实现删除  
​ **@Select:** 实现查询  
​ **@Result:** 实现结果集封装  
​ **@Results:** 可以与 @Result 一起使用，封装多个结果集  
​ **@ResultMap:** 实现引用 @Results 定义的封装  
​ **@One:** 实现一对一结果集封装  
​ **@Many:** 实现一对多结果集封装  
​ **@CacheNamespace:** 实现注解二级缓存的使用  
​ **@Param:** 多参数指定名字